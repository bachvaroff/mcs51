                   ; PAULMON2, a user-friendly 8051 monitor, by Paul Stoffregen
                   ; Please email comments, suggestions, bugs to paul@pjrc.com
                   ;
                   ; Version 2.1
                   ;        Download can start from main menu prompt
                   ;
                   ; Version 2.1ab
                   ;        Extensive mods by Atanas Bachvaroff <bachvaroff@gma
                   ;
                   ; See LICENSE
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;            PAULMON2's default configuration              ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ; These two parameters control where PAULMON2 will be assemb
                   ; and where it will attempt to LJMP at the interrupt vector 
0000:              .equ     base, 0x0000            ; location for PAULMON2
0000:              .equ     vector, 0x2000          ; location to LJMP interrup
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ; These three parameters tell PAULMON2 where the user's memo
                   ; installed. "bmem" and "emem" define the space that will be
                   ; for program headers, user installed commands, start-up pro
                   ; "bmem" and "emem" should be use so they exclude memory are
                   ; perphreal devices may be mapped, as reading memory from an
                   ; may reconfigure it unexpectedly.
0000:              .equ     pgm, 0x2000             ; default location for the 
0000:              .equ     bmem, 0x1000            ; where is the beginning of
0000:              .equ     emem, 0xdfff            ; end of the memory to sear
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
0000:              .equ     psw_init, 0             ; value for psw (which reg 
0000:              .equ     p2_init, 0xff           ; boot time default page is
0000:              .equ     sp_init, 0x17           ; location of the stack
0000:              .equ     sp_reset, 0x07          ; stack on reset
0000:              .equ     mctrl_reset, 11111111b  ; memory controller (P1) on
0000:              .equ     mctrl_shadow, 11111110b         ; memory controller
0000:              .equ     dnld_parm, 0x08                 ; block of 16 bytes
                   ; |00|01|02|03|04|05|06|07|08|09|0a|0b|0c|0d|0e|0f|
                   ;                         \__ sp_reset
                   ; |10|11|12|13|14|15|16|17|
                   ;                         \__ sp_init
                   ;
                   ; |r0|r1|r2|r3|r4|r5|r6|r7|  .  .  .  dnld  .  .  |
                   ; |  .  .  .  dnld  .  .  |
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ; bc = 65536 - (OSC / 32) / baud
                   ;---------------------------------------------------------;
                   ; 0xfffa @ 57600bps @ 11.059MHz
                   ;.equ    bc, 0xfffa
                   ; 0xfff7 @ 38400bps @ 11.059MHz
                   ;.equ    bc, 0xfff7
                   ; 0xffee @ 19200bps @ 11.059MHz
                   ;.equ    bc, 0xffee
                   ; 0xffdc @ 9600bps @ 11.059MHz
                   ;.equ    bc, 0xffdc
                   ; 0xfff7 @ 57600bps @ 16.5888MHz
0000:              .equ     bc, 0xfff7
                   ; 0xffee @ 28800bps @ 16.5888MHz
                   ;.equ    bc, 0xffee
                   ; 0xffe5 @ 19200bps @ 16.5888MHz
                   ;.equ    bc, 0xffe5
                   ; 0xffca @ 9600bps @ 16.5888MHz
                   ;.equ    bc, 0xffca
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ; Key command definitions
0000:              .equ     help_key, '?'           ; help screen
0000:              .equ     dir_key, 'M'            ; directory
0000:              .equ     run_key, 'R'            ; run program
0000:              .equ     dnld_key, 'D'           ; download
0000:              .equ     upld_key, 'U'           ; upload
0000:              .equ     nloc_key, 'N'           ; new memory location
0000:              .equ     jump_key, 'J'           ; jump to memory location
0000:              .equ     dump_key, 'H'           ; hex dump memory
0000:              .equ     intm_key, 'I'           ; hex dump internal memory
0000:              .equ     edit_key, 'E'           ; edit memory
0000:              .equ     clrm_key, 'C'           ; clear memory
0000:              .equ     crc16_key, 'W'          ; calculate crc16
0000:              .equ     baud_key, 'B'           ; reset baudrate
0000:              .equ     eio77_key, '<'          ; enable IO space 0xe000-0x
0000:              .equ     dio77_key, '>'          ; disable IO space 0xe000-0
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ; Common ASCII codes
0000:              .equ     LF, '\n'
0000:              .equ     CR, '\r'
0000:              .equ     ESC, 27
0000:              .equ     SPACE, ' '
0000:              .equ     pos_A, 'A'
0000:              .equ     neg_a, (-'a')
0000:              .equ     neg_zmap1, (-'z' + 'a' - 1)
                   ;---------------------------------------------------------;
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;                     Interrupt Vectors                    ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   ; spare the flash by filling the space between vectors
                   ; with "mov r7, a" / 0xff in binary
                   
                   ;------ RESET --------------------------------------------;
0000:              .org     base
0000: 02 0A 4D              ljmp    reset
                   ;------ RESET --------------------------------------------;
                   
                   ;------ IE0_VECTOR ---------------------------------------;
0003:              .org     base + 3
0003: 02 20 03              ljmp    vector + 3
0006: FF                    mov     r7, a
0007: FF                    mov     r7, a
0008: FF                    mov     r7, a
0009: FF                    mov     r7, a
000A: FF                    mov     r7, a
                   ;------ IE0_VECTOR ---------------------------------------;
                   
                   ;------ TF0_VECTOR ---------------------------------------;
000B:              .org     base + 11
000B: 02 20 0B              ljmp    vector + 11
000E: FF                    mov     r7, a
000F: FF                    mov     r7, a
0010: FF                    mov     r7, a
0011: FF                    mov     r7, a
0012: FF                    mov     r7, a
                   ;------ TF0_VECTOR ---------------------------------------;
                   
                   ;------ IE1_VECTOR ---------------------------------------;
0013:              .org     base + 19
0013: 02 20 13              ljmp    vector + 19
0016: FF                    mov     r7, a
0017: FF                    mov     r7, a
0018: FF                    mov     r7, a
0019: FF                    mov     r7, a
001A: FF                    mov     r7, a
                   ;------ IE1_VECTOR ---------------------------------------;
                   
                   ;------ TF1_VECTOR ---------------------------------------;
001B:              .org     base + 27
001B: 02 20 1B              ljmp    vector + 27
001E: FF                    mov     r7, a
001F: FF                    mov     r7, a
0020: FF                    mov     r7, a
0021: FF                    mov     r7, a
0022: FF                    mov     r7, a
                   ;------ TF1_VECTOR ---------------------------------------;
                   
                   ;------ SI0_VECTOR ---------------------------------------;
0023:              .org     base + 35
0023: 02 20 23              ljmp    vector + 35
0026: FF                    mov     r7, a
0027: FF                    mov     r7, a
0028: FF                    mov     r7, a
0029: FF                    mov     r7, a
002A: FF                    mov     r7, a
                   ;------ SI0_VECTOR ---------------------------------------;
                   
                   ;------ TF2_VECTOR --- EX2_VECTOR ------------------------;
002B:              .org     base + 43
002B: 02 20 2B              ljmp    vector + 43
002E: FF                    mov     r7, a
002F: FF                    mov     r7, a
0030: FF                    mov     r7, a
0031: FF                    mov     r7, a
0032: FF                    mov     r7, a
                   ;------ TF2_VECTOR --- EX2_VECTOR ------------------------;
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;        The jump table for user programs to call          ;
                   ;              subroutines within PAULMON                  ;
                   ;           Update paulmon21.equ accordingly               ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
0033:              .org     base + 51
0033: 02 00 75              ljmp    setbaud                 ; JMP_TABLE 0x0033
0036: 02 00 8E              ljmp    cin             ; JMP_TABLE 0x0036
0039: 02 00 96              ljmp    cinpoll                 ; JMP_TABLE 0x0039
003C: 02 00 A0              ljmp    cout            ; JMP_TABLE 0x003c
                            
003F: 02 01 E6              ljmp    phex            ; JMP_TABLE 0x003f
0042: 02 01 D2              ljmp    phex1           ; JMP_TABLE 0x0042
0045: 02 01 ED              ljmp    phex16          ; JMP_TABLE 0x0045
0048: 02 00 D7              ljmp    pcstr           ; JMP_TABLE 0x0048
004B: 02 00 E4              ljmp    pcb7str                 ; JMP_TABLE 0x004b
004E: 02 01 FA              ljmp    pint8u          ; JMP_TABLE 0x004e
0051: 02 02 00              ljmp    pint8           ; JMP_TABLE 0x0051
0054: 02 02 3A              ljmp    pint16u                 ; JMP_TABLE 0x0054
0057: 02 00 BA              ljmp    crlf            ; JMP_TABLE 0x0057
                            
005A: 02 00 F8              ljmp    ghex            ; JMP_TABLE 0x005a
005D: 02 01 3C              ljmp    ghex16          ; JMP_TABLE 0x005d
                            
0060: 02 01 B8              ljmp    asc2hex                 ; JMP_TABLE 0x0060
0063: 02 02 BF              ljmp    toupper                 ; JMP_TABLE 0x0063
0066: 02 02 C6              ljmp    lencstr                 ; JMP_TABLE 0x0066
0069: 02 02 D4              ljmp    lencb7str       ; JMP_TABLE 0x0069
                            
006C: 02 09 40              ljmp    init_crc16      ; JMP_TABLE 0x006c
006F: 02 09 54              ljmp    update_crc16    ; JMP_TABLE 0x006f
0072: 02 09 49              ljmp    finish_crc16    ; JMP_TABLE 0x0072
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;               Subroutines for serial I/O                 ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   setbaud:
0075: C2 CA                 clr     tr2
0077: F5 CC                 mov     tl2, a
0079: 85 F0 CD              mov     th2, b
007C: F5 CA                 mov     rcap2l, a
007E: 85 F0 CB              mov     rcap2h, b
0081: 75 C8 30              mov     t2con, #00110000b
0084: 75 98 52              mov     scon, #01010010b
0087: C2 98                 clr     ri
0089: C2 99                 clr     ti
008B: D2 CA                 setb    tr2
008D: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   cin:
008E: 30 98 FD              jnb     ri, cin
0091: E5 99                 mov     a, sbuf
0093: C2 98                 clr     ri
0095: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   cinpoll:
0096: D3                    setb    c
0097: 30 98 05              jnb     ri, cinpoll1
009A: E5 99                 mov     a, sbuf
009C: C2 98                 clr     ri
009E: C3                    clr     c
                   cinpoll1:
009F: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   cout:
00A0: 30 99 FD              jnb     ti, cout
00A3: C2 99                 clr     ti
00A5: F5 99                 mov     sbuf, a
00A7: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   sspace:
00A8: C0 E0                 push    acc
00AA: 74 20                 mov     a, #SPACE
00AC: 11 A0                 acall   cout
00AE: D0 E0                 pop     acc
00B0: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   dash:
00B1: C0 E0                 push    acc
00B3: 74 2D                 mov     a, #'-'
00B5: 11 A0                 acall   cout
00B7: D0 E0                 pop     acc
00B9: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   crlf:
00BA: C0 E0                 push    acc
00BC: 74 0D                 mov     a, #CR
00BE: 11 A0                 acall   cout
00C0: 74 0A                 mov     a, #LF
00C2: 11 A0                 acall   cout
00C4: D0 E0                 pop     acc
00C6: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   cout_sp:
00C7: 11 A0                 acall   cout
00C9: 01 A8                 ajmp    sspace
                   
                   ;---------------------------------------------------------;
                   
                   dash_sp:
00CB: 11 B1                 acall   dash
00CD: 01 A8                 ajmp    sspace
                   
                   ;---------------------------------------------------------;
                   
                   dspace:
00CF: 11 A8                 acall   sspace
00D1: 01 A8                 ajmp    sspace
                   
                   ;---------------------------------------------------------;
                   
                   dcrlf:
00D3: 11 BA                 acall   crlf
00D5: 01 BA                 ajmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   pcstr:
00D7: C0 E0                 push    acc
                   pcstr1:
00D9: E0                    movx    a, @dptr
00DA: A3                    inc     dptr
00DB: 60 04                 jz      pcstr2
00DD: 11 A0                 acall   cout
00DF: 80 F8                 sjmp    pcstr1
                   pcstr2:
00E1: D0 E0                 pop     acc
00E3: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   pcb7str:
00E4: C0 E0                 push    acc
                   pcb7str1:
00E6: E0                    movx    a, @dptr
00E7: A3                    inc     dptr
00E8: 60 0B                 jz      pcb7str3
00EA: 20 E7 04              jb      acc.7, pcb7str2
00ED: 11 A0                 acall   cout
00EF: 80 F5                 sjmp    pcb7str1
                   pcb7str2:
00F1: 54 7F                 anl     a, #0x7f
00F3: 11 A0                 acall   cout
                   pcb7str3:
00F5: D0 E0                 pop     acc
00F7: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; get 2 digit hex number from serial port
                   ; c = set if ESC pressed, clear otherwise
                   ; psw.5 = set if return w/ no input, clear otherwise
                   
                   ghex:
                   ghex8:
00F8: C2 D5                 clr     psw.5
                   ghex8c:
00FA: 11 8E                 acall   cin     ; get first digit
00FC: 51 BF                 acall   toupper
00FE: B4 1B 03              cjne    a, #ESC, ghex8f
                   ghex8d:
0101: D3                    setb    c
0102: E4                    clr     a
0103: 22                    ret
                   ghex8f:
0104: B4 0D 05              cjne    a, #CR, ghex8h
0107: D2 D5                 setb    psw.5
0109: C3                    clr     c
010A: E4                    clr     a
010B: 22                    ret
                   ghex8h:
010C: FA                    mov     r2, a
010D: 31 B8                 acall   asc2hex
010F: 40 E9                 jc      ghex8c
0111: CA                    xch     a, r2           ; r2 will hold hex value of
0112: 11 A0                 acall   cout
                   ghex8j:
0114: 11 8E                 acall   cin     ; get second digit
0116: 51 BF                 acall   toupper
0118: B4 1B 02              cjne    a, #ESC, ghex8k
011B: 80 E4                 sjmp    ghex8d
                   ghex8k:
011D: B4 0D 03              cjne    a, #CR, ghex8m
0120: EA                    mov     a, r2
0121: C3                    clr     c
0122: 22                    ret
                   ghex8m:
0123: B4 08 04              cjne    a, #8, ghex8p
                   ghex8n:
0126: 11 A0                 acall   cout
0128: 80 D0                 sjmp    ghex8c
                   ghex8p:
012A: B4 15 02              cjne    a, #21, ghex8q
012D: 80 F7                 sjmp    ghex8n
                   ghex8q:
012F: FB                    mov     r3, a
0130: 31 B8                 acall   asc2hex
0132: 40 E0                 jc      ghex8j
0134: CB                    xch     a, r3
0135: 11 A0                 acall   cout
0137: EA                    mov     a, r2
0138: C4                    swap    a
0139: 4B                    orl     a, r3
013A: C3                    clr     c
013B: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; carry set if esc pressed
                   ; psw.5 set if return pressed w/ no input
                   
                   ghex16:
013C: 7A 00                 mov     r2, #0          ; start out with 0
013E: 7B 00                 mov     r3, #0
0140: 7C 04                 mov     r4, #4          ; number of digits left
0142: C2 D5                 clr     psw.5
                   
                   ghex16c:
0144: 11 8E                 acall   cin
0146: 51 BF                 acall   toupper
0148: B4 1B 07              cjne    a, #ESC, ghex16d
014B: D3                    setb    c               ; handle esc key
014C: E4                    clr     a
014D: F5 83                 mov     dph, a
014F: F5 82                 mov     dpl, a
0151: 22                    ret
                   ghex16d:
0152: B4 08 02              cjne    a, #8, ghex16f
0155: 80 03                 sjmp    ghex16k
                   ghex16f:
0157: B4 7F 0C              cjne    a, #127, ghex16g        ; handle backspace
                   ghex16k:
015A: BC 04 02              cjne    r4, #4, ghex16e                 ; have they
015D: 80 E5                 sjmp    ghex16c
                   ghex16e:
015F: 11 A0                 acall   cout
0161: 31 A7                 acall   ghex16y
0163: 0C                    inc     r4
0164: 80 DE                 sjmp    ghex16c
                   ghex16g:
0166: B4 0D 10              cjne    a, #CR, ghex16i                 ; return ke
0169: 8B 83                 mov     dph, r3
016B: 8A 82                 mov     dpl, r2
016D: BC 04 07              cjne    r4, #4, ghex16h
0170: E4                    clr     a
0171: F5 83                 mov     dph, a
0173: F5 82                 mov     dpl, a
0175: D2 D5                 setb    psw.5
                   ghex16h:
0177: C3                    clr     c
0178: 22                    ret
                   ghex16i:
0179: FD                    mov     r5, a                   ; keep copy of orig
017A: 31 B8                 acall   asc2hex
017C: 40 C6                 jc      ghex16c
017E: CD                    xch     a, r5
017F: 12 00 A0              lcall   cout
0182: ED                    mov     a, r5
0183: C0 E0                 push    acc
0185: 31 96                 acall   ghex16x
0187: D0 E0                 pop     acc
0189: 2A                    add     a, r2
018A: FA                    mov     r2, a
018B: E4                    clr     a
018C: 3B                    addc    a, r3
018D: FB                    mov     r3, a
018E: DC B4                 djnz    r4, ghex16c
0190: C3                    clr     c
0191: 8A 82                 mov     dpl, r2
0193: 8B 83                 mov     dph, r3
0195: 22                    ret
                   
                   ghex16x:
                   ; multiply r3-r2 by 16 (shift left by 4)
0196: EB                    mov     a, r3
0197: C4                    swap    a
0198: 54 F0                 anl     a, #11110000b
019A: FB                    mov     r3, a
019B: EA                    mov     a, r2
019C: C4                    swap    a
019D: 54 0F                 anl     a, #00001111b
019F: 4B                    orl     a, r3
01A0: FB                    mov     r3, a
01A1: EA                    mov     a, r2
01A2: C4                    swap    a
01A3: 54 F0                 anl     a, #11110000b
01A5: FA                    mov     r2, a
01A6: 22                    ret
                   
                   ghex16y:
                   ; divide r3-r2 by 16 (shift right by 4)
01A7: EA                    mov     a, r2
01A8: C4                    swap    a
01A9: 54 0F                 anl     a, #00001111b
01AB: FA                    mov     r2, a
01AC: EB                    mov     a, r3
01AD: C4                    swap    a
01AE: 54 F0                 anl     a, #11110000b
01B0: 4A                    orl     a, r2
01B1: FA                    mov     r2, a
01B2: EB                    mov     a, r3
01B3: C4                    swap    a
01B4: 54 0F                 anl     a, #00001111b
01B6: FB                    mov     r3, a
01B7: 22                    ret
                   
                   asc2hex:
                   ; carry set if invalid input
01B8: 24 D0                 add     a, #208
01BA: 50 14                 jnc     hex_not
01BC: 24 F6                 add     a, #246
01BE: 40 04                 jc      hex_maybe
01C0: 24 0A                 add     a, #10
01C2: C3                    clr     c
01C3: 22                    ret
                   hex_maybe:
01C4: 24 F9                 add     a, #249
01C6: 50 08                 jnc     hex_not
01C8: 24 FA                 add     a, #250
01CA: 40 04                 jc      hex_not
01CC: 24 10                 add     a, #16
01CE: C3                    clr     c
01CF: 22                    ret
                   hex_not:
01D0: D3                    setb    c
01D1: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   phex1:
01D2: C0 E0                 push    acc
01D4: 54 0F                 anl     a, #0x0f
01D6: 24 F6                 add     a, #(-0x0a)
01D8: 20 E7 04              jb      acc.7, phex1_0_9
01DB: 24 41                 add     a, #'A'
01DD: 80 02                 sjmp    phex1_print
                   phex1_0_9:
01DF: 24 3A                 add     a, #('0' + 0x0a)
                   phex1_print:
01E1: 11 A0                 acall   cout
01E3: D0 E0                 pop     acc
01E5: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   phex:
                   phex8:
01E6: C4                    swap    a
01E7: 31 D2                 acall   phex1
01E9: C4                    swap    a
01EA: 31 D2                 acall   phex1
01EC: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   phex16:
01ED: C0 E0                 push    acc
01EF: E5 83                 mov     a, dph
01F1: 31 E6                 acall   phex
01F3: E5 82                 mov     a, dpl
01F5: 31 E6                 acall   phex
01F7: D0 E0                 pop     acc
01F9: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; prints the unsigned 8 bit value in Acc in base 10
                   
                   pint8u:
01FA: C0 F0                 push    b
01FC: C0 E0                 push    acc
01FE: 80 12                 sjmp    pint8b
                   
                   ;---------------------------------------------------------;
                   
                   ; prints the signed 8 bit value in Acc in base 10
                   
                   pint8:
0200: C0 F0                 push    b
0202: C0 E0                 push    acc
0204: 30 E7 0B              jnb     acc.7, pint8b
0207: 74 2D                 mov     a, #'-'
0209: 11 A0                 acall   cout
020B: D0 E0                 pop     acc
020D: C0 E0                 push    acc
020F: F4                    cpl     a
0210: 24 01                 add     a, #1
                   pint8b:
0212: 75 F0 64              mov     b, #100
0215: 84                    div     ab
0216: D2 D5                 setb    f0
0218: 60 06                 jz      pint8c
021A: C2 D5                 clr     f0
021C: 24 30                 add     a, #'0'
021E: 11 A0                 acall   cout
                   pint8c:
0220: E5 F0                 mov     a, b
0222: 75 F0 0A              mov     b, #10
0225: 84                    div     ab
0226: 30 D5 02              jnb     f0, pint8d
0229: 60 04                 jz      pint8e
                   pint8d:
022B: 24 30                 add     a, #'0'
022D: 11 A0                 acall   cout
                   pint8e:
022F: E5 F0                 mov     a, b
0231: 24 30                 add     a, #'0'
0233: 11 A0                 acall   cout
0235: D0 E0                 pop     acc
0237: D0 F0                 pop     b
0239: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; print 16 bit unsigned integer in DPTR, using base 10.
                   ; warning, destroys r2, r3, r4, r5, psw.5
                   
                   pint16u:
023A: C0 E0                 push    acc
023C: E8                    mov     a, r0
023D: C0 E0                 push    acc
023F: C2 D5                 clr     psw.5
0241: AA 82                 mov     r2, dpl
0243: AB 83                 mov     r3, dph
                   pint16a:
0245: 7C 10                 mov     r4, #16                 ; 10^4
0247: 7D 27                 mov     r5, #39
0249: 51 93                 acall   pint16x
024B: 60 06                 jz      pint16b
024D: 24 30                 add     a, #'0'
024F: 11 A0                 acall   cout
0251: D2 D5                 setb    psw.5
                   pint16b:
0253: 7C E8                 mov     r4, #232        ; 10^3
0255: 7D 03                 mov     r5, #3
0257: 51 93                 acall   pint16x
0259: 70 03                 jnz     pint16c
025B: 30 D5 06              jnb     psw.5, pint16d
                   pint16c:
025E: 24 30                 add     a, #'0'
0260: 11 A0                 acall   cout
0262: D2 D5                 setb    psw.5
                   pint16d:
0264: 7C 64                 mov     r4, #100        ; 10^2
0266: 7D 00                 mov     r5, #0
0268: 51 93                 acall   pint16x
026A: 70 03                 jnz     pint16e
026C: 30 D5 06              jnb     psw.5, pint16f
                   pint16e:
026F: 24 30                 add     a, #'0'
0271: 11 A0                 acall   cout
0273: D2 D5                 setb    psw.5
                   pint16f:
0275: EA                    mov     a, r2           ; 10^1
0276: AB F0                 mov     r3, b
0278: 75 F0 0A              mov     b, #10
027B: 84                    div     ab
027C: 70 03                 jnz     pint16g
027E: 30 D5 04              jnb     psw.5, pint16h
                   pint16g:
0281: 24 30                 add     a, #'0'
0283: 11 A0                 acall   cout
                   pint16h:
0285: E5 F0                 mov     a, b            ; 10^0
0287: 8B F0                 mov     b, r3
0289: 24 30                 add     a, #'0'
028B: 11 A0                 acall   cout
028D: D0 E0                 pop     acc
028F: F8                    mov     r0, a
0290: D0 E0                 pop     acc
0292: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; ok, it's a cpu hog and a nasty way to divide, but this cod
                   ; requires only 21 bytes! Divides r2-r3 by r4-r5 and leaves
                   ; quotient in r2-r3 and returns remainder in acc. If Intel
                   ; had made a proper divide, then this would be much easier.
                   
                   pint16x:
0293: 78 00                 mov     r0, #0
                   pint16y:
0295: 08                    inc     r0
0296: C3                    clr     c
0297: EA                    mov     a, r2
0298: 9C                    subb    a, r4
0299: FA                    mov     r2, a
029A: EB                    mov     a, r3
029B: 9D                    subb    a, r5
029C: FB                    mov     r3, a
029D: 50 F6                 jnc     pint16y
029F: 18                    dec     r0
02A0: EA                    mov     a, r2
02A1: 2C                    add     a, r4
02A2: FA                    mov     r2, a
02A3: EB                    mov     a, r3
02A4: 3D                    addc    a, r5
02A5: FB                    mov     r3, a
02A6: E8                    mov     a, r0
02A7: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   islower:
02A8: 20 E7 12              jb      acc.7, islower_out0
02AB: C0 E0                 push    acc
02AD: 24 9F                 add     a, #neg_a
02AF: 20 E7 09              jb      acc.7, islower_out1
02B2: 24 E6                 add     a, #neg_zmap1
02B4: 30 E7 04              jnb     acc.7, islower_out1
02B7: D0 E0                 pop     acc
02B9: D3                    setb    c
02BA: 22                    ret
                   islower_out1:
02BB: D0 E0                 pop     acc
                   islower_out0:
02BD: C3                    clr     c
02BE: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   toupper:
02BF: 51 A8                 acall   islower
02C1: 50 02                 jnc     toupper_out
02C3: 24 E0                 add     a, #(neg_a + pos_A)
                   toupper_out:
02C5: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   lencstr:
02C6: 78 00                 mov     r0, #0          ; returns length of a strin
02C8: C0 E0                 push    acc
                   lencstr1:
02CA: E0                    movx    a, @dptr
02CB: 60 04                 jz      lencstr2
02CD: 08                    inc     r0
02CE: A3                    inc     dptr
02CF: 80 F9                 sjmp    lencstr1
                   lencstr2:
02D1: D0 E0                 pop     acc
02D3: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   lencb7str:
02D4: 78 00                 mov     r0, #0
02D6: C0 E0                 push    acc
                   lencb7str1:
02D8: E0                    movx    a, @dptr
02D9: 60 07                 jz      lencb7str2
02DB: 08                    inc     r0
02DC: 20 E7 03              jb      acc.7, lencb7str2
02DF: A3                    inc     dptr
02E0: 80 F6                 sjmp    lencb7str1
                   lencb7str2:
02E2: D0 E0                 pop     acc
02E4: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   menu:
                   ; first we print out the prompt, which isn't as simple
                   ; as it may seem, since external code can add to the
                   ; prompt, so we've got to find and execute all of 'em.
02E5: 90 0A E8              mov     dptr, #prompt1  ; give 'em the first part o
02E8: 11 D7                 acall   pcstr
02EA: EF                    mov     a, r7
02EB: 31 E6                 acall   phex
02ED: EE                    mov     a, r6
02EE: 31 E6                 acall   phex
02F0: 90 0A F2              mov     dptr, #prompt2
02F3: 11 D7                 acall   pcstr
                            
                   ; now we're finally past the prompt, so let's get some input
02F5: 11 8E                 acall   cin             ; get the input, finally
02F7: B4 3A 04              cjne    a, #':', menu0
02FA: 71 FE                 acall   dnld_now
02FC: 80 E7                 sjmp    menu
                   menu0:
02FE: 51 BF                 acall   toupper
                            
                   ; push return address onto stack so we can just jump to the 
0300: 75 F0 E5              mov     b, #(menu & 0xff)       ; we push the retur
0303: C0 F0                 push    b               ; to save code later...
0305: 75 F0 02              mov     b, #(menu >> 8)         ; if bogus input, j
0308: C0 F0                 push    b               ; another prompt.
                            
                   ; first we'll look through memory for a program header that 
                   ; it's a user installed command which matches what the user 
                            
                   ; user installed commands need to avoid changing R6/R7, whic
                   ; the memory pointer. The stack pointer can't be changed obv
                   ; all the other general purpose registers should be availabl
                   ; user commands to alter as they wish.
                            
                   menux:
030A: F5 F0                 mov     b, a            ; now search for external c
030C: 90 10 00              mov     dptr, #bmem
                   menux1:
030F: 12 09 B0              lcall   find
0312: 50 22                 jnc     menuxend        ; searched all the commands
0314: 75 82 04              mov     dpl, #4
0317: E0                    movx    a, @dptr
0318: B4 FE 14              cjne    a, #254, menux2         ; only FE is an ext
031B: 05 82                 inc     dpl
031D: E0                    movx    a, @dptr
031E: B5 F0 0E              cjne    a, b, menux2    ; only run if they want it
0321: 11 A8                 acall   sspace
0323: 75 82 20              mov     dpl, #32
0326: 11 D7                 acall   pcstr           ; print command name
0328: 11 BA                 acall   crlf
032A: 75 82 40              mov     dpl, #64
032D: E4                    clr     a
032E: 73                    jmp     @a+dptr                 ; take a leap of fa
                   menux2:
032F: 05 83                 inc     dph
0331: E5 83                 mov     a, dph
0333: B4 E0 D9              cjne    a, #((emem + 1) >> 8) & 0xff, menux1
                   menuxend:
0336: E5 F0                 mov     a, b
                            
                   ; since we didn't find a user installed command, use the bui
                   menui1:
0338: B4 3F 07              cjne    a, #help_key, menui2
033B: 90 0E 43              mov     dptr, #help_cmd2
033E: 11 D7                 acall   pcstr
0340: E1 00                 ajmp    help
                            
                   menui2:
0342: B4 4D 07              cjne    a, #dir_key, menui3
0345: 90 0E 57              mov     dptr, #dir_cmd
0348: 11 D7                 acall   pcstr
034A: A1 EE                 ajmp    dir
                            
                   menui3:
034C: B4 52 07              cjne    a, #run_key, menui4
034F: 90 0E 65              mov     dptr, #run_cmd
0352: 11 D7                 acall   pcstr
0354: C1 68                 ajmp    run
                            
                   menui4:
0356: B4 44 07              cjne    a, #dnld_key, menui5
0359: 90 0E 71              mov     dptr, #dnld_cmd
035C: 11 D7                 acall   pcstr
035E: 61 E1                 ajmp    dnld
                            
                   menui5:
0360: B4 55 07              cjne    a, #upld_key, menui6
0363: 90 0E 7A              mov     dptr, #upld_cmd
0366: 11 D7                 acall   pcstr
0368: E1 A6                 ajmp    upld
                            
                   menui6:
036A: B4 4E 08              cjne    a, #nloc_key, menui7
036D: 90 0E 81              mov     dptr, #nloc_cmd
0370: 11 D7                 acall   pcstr
0372: 02 08 7F              ljmp    nloc
                            
                   menui7:
0375: B4 4A 07              cjne    a, #jump_key, menui8
0378: 90 0E 8E              mov     dptr, #jump_cmd
037B: 11 D7                 acall   pcstr
037D: A1 48                 ajmp    jump
                            
                   menui8:
037F: B4 48 07              cjne    a, #dump_key, menui9
0382: 90 0E A6              mov     dptr, #dump_cmd
0385: 11 D7                 acall   pcstr
0387: A1 79                 ajmp    dump
                            
                   menui9:
0389: B4 45 07              cjne    a, #edit_key, menui10
038C: 90 0E D8              mov     dptr, #edit_cmd
038F: 11 D7                 acall   pcstr
0391: A1 BB                 ajmp    edit
                            
                   menui10:
0393: B4 43 08              cjne    a, #clrm_key, menui11
0396: 90 0E ED              mov     dptr, #clrm_cmd
0399: 11 D7                 acall   pcstr
039B: 02 08 93              ljmp    clrm
                            
                   menui11:
039E: B4 49 08              cjne    a, #intm_key, menui12
03A1: 90 0E BF              mov     dptr, #intm_cmd
03A4: 11 D7                 acall   pcstr
03A6: 02 09 80              ljmp    intm
                            
                   menui12:
03A9: B4 3C 08              cjne    a, #eio77_key, menui13
03AC: 90 0F 13              mov     dptr, #eio77_cmd
03AF: 11 D7                 acall   pcstr
03B1: 02 09 A6              ljmp    eio77
                            
                   menui13:
03B4: B4 3E 08              cjne    a, #dio77_key, menui14
03B7: 90 0F 22              mov     dptr, #dio77_cmd
03BA: 11 D7                 acall   pcstr
03BC: 02 09 AB              ljmp    dio77
                            
                   menui14:
03BF: B4 57 08              cjne    a, #crc16_key, menui15
03C2: 90 0F 03              mov     dptr, #crc16_cmd
03C5: 11 D7                 acall   pcstr
03C7: 02 08 FE              ljmp    calc_crc16
                            
                   menui15:
03CA: B4 42 08              cjne    a, #baud_key, menuiend
03CD: 90 0F 32              mov     dptr, #baud_cmd
03D0: 11 D7                 acall   pcstr
03D2: 02 08 BC              ljmp    reset_baud
                            
                   menuiend:
03D5: 01 BA                 ajmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   r6r7todptr:
03D7: 8E 82                 mov     dpl, r6
03D9: 8F 83                 mov     dph, r7
03DB: 22                    ret
                   
                   dptrtor6r7:
03DC: AE 82                 mov     r6, dpl
03DE: AF 83                 mov     r7, dph
03E0: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; dnlds1 = "Begin sending Intel HEX format file <ESC> to abo
                   ; dnlds2 = "Download aborted"
                   ; dnlds3 = "Download completed"
                   
                   ; 16 byte parameter table: (eight 16 bit values)
                   ;  *   0 = lines received
                   ;  *   1 = bytes received
                   ;  *   2 = bytes written
                   ;  *   3 = bytes unable to write
                   ;  *   4 = incorrect checksums
                   ;  *   5 = unexpected begin of line
                   ;  *   6 = unexpected hex digits (while waiting for bol)
                   ;  *   7 = unexpected non-hex digits (in middle of a line)
                   
                   dnld:
03E1: 90 0C 5A              mov     dptr, #dnlds1   ; "begin sending file <ESC>
03E4: 11 D7                 acall   pcstr
03E6: B1 3F                 acall   dnld_init
                            
                   dnld1:
                   ; look for begining of line marker ':'
03E8: 11 8E                 acall   cin
03EA: B4 1B 02              cjne    a, #ESC, dnld2  ; Test for escape
03ED: 80 6D                 sjmp    dnld_esc
                            
                   dnld2:
03EF: B4 3A 02              cjne    a, #':', dnld2b
03F2: 80 10                 sjmp    dnld2d
                   dnld2b:
                   ; check to see if it's a hex digit, error if it is
03F4: 31 B8                 acall   asc2hex
03F6: 40 F0                 jc      dnld1
03F8: 79 06                 mov     r1, #6
03FA: 91 6E                 acall   dnld_inc
03FC: 80 EA                 sjmp    dnld1
                            
                   dnld_now:
                   ; entry point for main menu detecting ':' character
03FE: 74 3A                 mov     a, #':'
0400: 11 A0                 acall   cout
0402: B1 3F                 acall   dnld_init
                            
                   dnld2d:
0404: 79 00                 mov     r1, #0
0406: 91 6E                 acall   dnld_inc
                            
                   dnld3:
                   ; begin taking in the line of data
                   ;        mov     a, #'.'
                   ;        acall   cout
0408: 7C 00                 mov     r4, #0          ; r4 will count up checksum
040A: 91 8D                 acall   dnld_ghex
040C: F8                    mov     r0, a           ; R0 = # of data bytes
                   ;        mov     a, #'.'
                   ;        acall   cout
040D: 91 8D                 acall   dnld_ghex
040F: F5 83                 mov     dph, a          ; High byte of load address
0411: 91 8D                 acall   dnld_ghex
0413: F5 82                 mov     dpl, a          ; Low byte of load address
0415: 91 8D                 acall   dnld_ghex       ; Record type
0417: B4 01 02              cjne    a, #1, dnld4    ; End record?
041A: 80 29                 sjmp    dnld_end
                   dnld4:
041C: 70 1E                 jnz     dnld_unknown    ; is it a unknown record ty
                   dnld5:
041E: E8                    mov     a, r0
041F: 60 10                 jz      dnld_get_cksum
0421: 91 8D                 acall   dnld_ghex       ; Get data byte
0423: FA                    mov     r2, a
0424: 79 01                 mov     r1, #1
0426: 91 6E                 acall   dnld_inc        ; count total data bytes re
0428: EA                    mov     a, r2
0429: F0                    movx    @dptr, a
042A: 79 02                 mov     r1, #2
042C: 91 6E                 acall   dnld_inc
042E: A3                    inc     dptr
042F: D8 ED                 djnz    r0, dnld5
                   dnld_get_cksum:
0431: 91 8D                 acall   dnld_ghex       ; get checksum
0433: EC                    mov     a, r4
0434: 60 B2                 jz      dnld1           ; should always add to zero
                   dnld_sumerr:
0436: 79 04                 mov     r1, #4
0438: 91 6E                 acall   dnld_inc        ; all we can do it count # 
043A: 80 AC                 sjmp    dnld1
                            
                   dnld_unknown:
                   ; handle unknown line type
043C: E8                    mov     a, r0
043D: 60 F2                 jz      dnld_get_cksum  ; skip data if size is zero
                   dnld_ukn2:
043F: 91 8D                 acall   dnld_ghex       ; consume all of unknown da
0441: D8 FC                 djnz    r0, dnld_ukn2
0443: 80 EC                 sjmp    dnld_get_cksum
                            
                   dnld_end:
                   ; handles the proper end-of-download marker
0445: E8                    mov     a, r0
0446: 60 04                 jz      dnld_end_3      ; should usually be zero
                   dnld_end_2:
0448: 91 8D                 acall   dnld_ghex       ; consume all of useless da
044A: D8 F3                 djnz    r0, dnld_ukn2
                   dnld_end_3:
044C: 91 8D                 acall   dnld_ghex       ; get the last checksum
044E: EC                    mov     a, r4
044F: 70 E5                 jnz     dnld_sumerr
0451: 91 65                 acall   dnld_dly
0453: 90 0C A8              mov     dptr, #dnlds3   ; "download went ok..."
0456: 11 D7                 acall   pcstr
                   ; consume any cr or lf character that may have been
                   ; on the end of the last line
0458: 11 96                 acall   cinpoll
045A: 80 76                 sjmp    dnld_sum
                            
                   dnld_esc:
                   ; handle esc received in the download stream
045C: 91 65                 acall   dnld_dly
045E: 90 0C 91              mov     dptr, #dnlds2   ; "download aborted."
0461: 11 D7                 acall   pcstr
0463: 80 6D                 sjmp    dnld_sum
                   
                   ; a short delay since most terminal emulation programs
                   ; won't be ready to receive anything immediately after
                   ; they've transmitted a file... even on a fast Pentium(tm)
                   ; machine with 16550 uarts!
                            
                   dnld_dly:
0465: 78 00                 mov     r0, #0
                   dnlddly2:
0467: 79 00                 mov     r1, #0
0469: D9 FE                 djnz    r1, *           ; roughly 128k cycles, appo
046B: D8 FA                 djnz    r0, dnlddly2
046D: 22                    ret
                            
                   ; increment parameter specified by R1
                   ; note, values in Acc and R1 are destroyed
                            
                   dnld_inc:
046E: E9                    mov     a, r1
046F: 54 07                 anl     a, #00000111b   ; just in case
0471: 23                    rl      a
0472: 24 08                 add     a, #dnld_parm
0474: F9                    mov     r1, a           ; now r1 points to lsb
0475: 07                    inc     @r1
0476: E7                    mov     a, @r1
0477: 70 02                 jnz     dnldin2
0479: 09                    inc     r1
047A: 07                    inc     @r1
                   dnldin2:
047B: 22                    ret
                            
                   ; get parameter, and inc to next one (@r1)
                   ; carry clear if parameter is zero.
                   ; 16 bit value returned in dptr
                            
                   dnld_gp:
047C: D3                    setb    c
047D: 87 82                 mov     dpl, @r1
047F: 09                    inc     r1
0480: 87 83                 mov     dph, @r1
0482: 09                    inc     r1
0483: E5 82                 mov     a, dpl
0485: 70 05                 jnz     dnldgp2
0487: E5 83                 mov     a, dph
0489: 70 01                 jnz     dnldgp2
048B: C3                    clr     c
                   dnldgp2:
048C: 22                    ret
                            
                   ; a special version of ghex just for the download. Does not
                   ; look for carriage return or backspace. Handles ESC key by
                   ; poping the return address (I know, nasty, but it saves man
                   ; bytes of code in this 4k ROM) and then jumps to the esc
                   ; key handling.  This ghex doesn't echo characters, and if i
                   ; sees ':', it pops the return and jumps to an error handler
                   ; for ':' in the middle of a line. Non-hex digits also jump
                   ; to error handlers, depending on which digit.
                            
                   dnld_ghex:
                   dnldgh1:
048D: 11 8E                 acall   cin
048F: 51 BF                 acall   toupper
0491: B4 1B 06              cjne    a, #ESC, dnldgh3
                   dnldgh2:
0494: D0 E0                 pop     acc
0496: D0 E0                 pop     acc
0498: 80 C2                 sjmp    dnld_esc
                   dnldgh3:
049A: B4 3A 0A              cjne    a, #':', dnldgh5
                   dnldgh4:
049D: 79 05                 mov     r1, #5          ; handle unexpected beginni
049F: 91 6E                 acall   dnld_inc
04A1: D0 E0                 pop     acc
04A3: D0 E0                 pop     acc
04A5: 81 08                 ajmp    dnld3           ; and now we're on a new li
                   dnldgh5:
04A7: 31 B8                 acall   asc2hex
04A9: 50 06                 jnc     dnldgh6
04AB: 79 07                 mov     r1, #7
04AD: 91 6E                 acall   dnld_inc
04AF: 80 DC                 sjmp    dnldgh1
                   dnldgh6:
04B1: FA                    mov     r2, a           ; keep first digit in r2
                   dnldgh7:
04B2: 11 8E                 acall   cin
04B4: 51 BF                 acall   toupper
04B6: B4 1B 02              cjne    a, #ESC, dnldgh8
04B9: 80 D9                 sjmp    dnldgh2
                   dnldgh8:
04BB: B4 3A 02              cjne    a, #':', dnldgh9
04BE: 80 DD                 sjmp    dnldgh4
                   dnldgh9:
04C0: 31 B8                 acall   asc2hex
04C2: 50 06                 jnc     dnldghA
04C4: 79 07                 mov     r1, #7
04C6: 91 6E                 acall   dnld_inc
04C8: 80 E8                 sjmp    dnldgh7
                   dnldghA:
04CA: CA                    xch     a, r2
04CB: C4                    swap    a
04CC: 4A                    orl     a, r2
04CD: FA                    mov     r2, a
04CE: 2C                    add     a, r4           ; add into checksum
04CF: FC                    mov     r4, a
04D0: EA                    mov     a, r2           ; return value in acc
04D1: 22                    ret
                            
                   ; print out download summary
                   ; dnlds4 = "Summary:"
                   ; dnlds5 = " lines received"
                   ; dnlds6a = " bytes received"
                   ; dnlds6b = " bytes written"
                            
                   dnld_sum:
04D2: EE                    mov     a, r6
04D3: C0 E0                 push    acc
04D5: EF                    mov     a, r7
04D6: C0 E0                 push    acc
04D8: 90 0C C1              mov     dptr, #dnlds4
04DB: 11 D7                 acall   pcstr
04DD: 79 08                 mov     r1, #dnld_parm
04DF: 7E CC                 mov     r6, #dnlds5 & 0xff
04E1: 7F 0C                 mov     r7, #dnlds5 >> 8
04E3: B1 3B                 acall   dnld_i0
04E5: 7E DF                 mov     r6, #dnlds6a & 0xff
04E7: 7F 0C                 mov     r7, #dnlds6a >> 8
04E9: B1 3B                 acall   dnld_i0
04EB: 7E F2                 mov     r6, #dnlds6b & 0xff
04ED: 7F 0C                 mov     r7, #dnlds6b >> 8
04EF: B1 3B                 acall   dnld_i0
                            
                   ; now print out error summary
                   ; dnlds7 = "Errors:"
                   ; dnlds8 = " bytes unable to write"
                   ; dnlds9 = " incorrect checksums"
                   ; dnlds10 = " unexpected begin of line"
                   ; dnlds11 = " unexpected hex digits"
                   ; dnlds12 = " unexpected non-hex digits"
                   ; dnlds13 = "No errors detected"
                            
                   dnld_err:
04F1: 7A 05                 mov     r2, #5
                   dnlder2:
04F3: 91 7C                 acall   dnld_gp
04F5: 40 09                 jc      dnlder3                 ; any errors?
04F7: DA FA                 djnz    r2, dnlder2
                   ; no errors, so we print the nice message
04F9: 90 0D 8F              mov     dptr, #dnlds13
04FC: 11 D7                 acall   pcstr
04FE: 80 25                 sjmp    dlnd_sum_done
                            
                   dnlder3:
                   ; there were errors, so now we print 'em
0500: 90 0D 04              mov     dptr, #dnlds7
0503: 11 D7                 acall   pcstr
                   ; but let's not be nasty... only print if necessary
0505: 79 0E                 mov     r1, #(dnld_parm + 6)
0507: 7E 0E                 mov     r6, #dnlds8 & 0xff
0509: 7F 0D                 mov     r7, #dnlds8 >> 8
050B: B1 2D                 acall   dnld_item
050D: 7E 28                 mov     r6, #dnlds9 & 0xff
050F: 7F 0D                 mov     r7, #dnlds9 >> 8
0511: B1 2D                 acall   dnld_item
0513: 7E 3A                 mov     r6, #dnlds10 & 0xff
0515: 7F 0D                 mov     r7, #dnlds10 >> 8
0517: B1 2D                 acall   dnld_item
0519: 7E 57                 mov     r6, #dnlds11 & 0xff
051B: 7F 0D                 mov     r7, #dnlds11 >> 8
051D: B1 2D                 acall   dnld_item
051F: 7E 71                 mov     r6, #dnlds12 & 0xff
0521: 7F 0D                 mov     r7, #dnlds12 >> 8
0523: B1 2D                 acall   dnld_item
                   dlnd_sum_done:
0525: D0 E0                 pop     acc
0527: FF                    mov     r7, a
0528: D0 E0                 pop     acc
052A: FE                    mov     r6, a
052B: 01 BA                 ajmp    crlf
                            
                   dnld_item:
052D: 91 7C                 acall   dnld_gp                 ; error conditions
052F: 50 09                 jnc     dnld_i3
                   dnld_i2:
0531: 11 A8                 acall   sspace
0533: 12 02 3A              lcall   pint16u
0536: 71 D7                 acall   r6r7todptr
0538: 11 D7                 acall   pcstr
                   dnld_i3:
053A: 22                    ret
                            
                   dnld_i0:
053B: 91 7C                 acall   dnld_gp                 ; non-error conditi
053D: 80 F2                 sjmp    dnld_i2
                            
                   dnld_init:
                   ; init all dnld parms to zero.
053F: 78 08                 mov     r0, #dnld_parm
                   dnld0:
0541: 76 00                 mov     @r0, #0
0543: 08                    inc     r0
0544: B8 18 FA              cjne    r0, #dnld_parm + 16, dnld0
0547: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   jump:
0548: 90 0B 7F              mov     dptr, #prompt8
054B: 11 D7                 acall   pcstr
054D: 71 D7                 acall   r6r7todptr
054F: 31 ED                 acall   phex16
0551: 90 0B 0E              mov     dptr, #prompt4
0554: 11 D7                 acall   pcstr
0556: 31 3C                 acall   ghex16
0558: 20 D5 07              jb      psw.5, jump3
055B: 50 03                 jnc     jump2
055D: 02 08 79              ljmp    abort2
                   jump2:
0560: 71 DC                 acall   dptrtor6r7
                   jump3:
0562: 11 BA                 acall   crlf
0564: 90 0D A6              mov     dptr, #runs1
0567: 11 D7                 acall   pcstr
0569: 71 D7                 acall   r6r7todptr
                   jump_doit:
056B: E4                    clr     a
056C: F5 D0                 mov     psw, a
056E: 75 81 07              mov     sp, #sp_reset
0571: F5 F0                 mov     b, a
0573: 78 FF                 mov     r0, #0xff
                   clrintram:
0575: F6                    mov     @r0, a
0576: D8 FD                 djnz    r0, clrintram
0578: 73                    jmp     @a+dptr
                   
                   ;---------------------------------------------------------;
                   
                   dump:
0579: 7A 10                 mov     r2, #16                 ; number of lines t
057B: 11 D3                 acall   dcrlf
                   dump1:
057D: 71 D7                 acall   r6r7todptr
057F: 31 ED                 acall   phex16          ; tell 'em the memory locat
0581: 74 3A                 mov     a, #':'
0583: 11 C7                 acall   cout_sp
0585: 7B 10                 mov     r3, #16                 ; r3 counts # of by
0587: 71 D7                 acall   r6r7todptr
                   dump2:
0589: E0                    movx    a, @dptr
058A: A3                    inc     dptr
058B: 31 E6                 acall   phex            ; print each byte in hex
058D: 11 A8                 acall   sspace
058F: DB F8                 djnz    r3, dump2
0591: 11 CF                 acall   dspace          ; print a couple extra spac
0593: 7B 10                 mov     r3, #16
0595: 71 D7                 acall   r6r7todptr
                   dump3:
0597: E0                    movx    a, @dptr
0598: A3                    inc     dptr
0599: 54 7F                 anl     a, #01111111b   ; avoid unprintable charact
059B: B4 7F 01              cjne    a, #127, dump3b
059E: E4                    clr     a               ; avoid 127/255 (delete/rub
                   dump3b:
059F: 24 E0                 add     a, #224
05A1: 40 01                 jc      dump4
05A3: E4                    clr     a               ; avoid control characters
                   dump4:
05A4: 24 20                 add     a, #32
05A6: 11 A0                 acall   cout
05A8: DB ED                 djnz    r3, dump3
05AA: 11 BA                 acall   crlf
05AC: 71 DC                 acall   dptrtor6r7
05AE: 11 96                 acall   cinpoll
05B0: 40 05                 jc      dump4b
05B2: B4 1B 02              cjne    a, #ESC, dump4b
05B5: 01 BA                 ajmp    crlf
                   dump4b:
05B7: DA C4                 djnz    r2, dump1       ; loop back up to print nex
05B9: 01 BA                 ajmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   ; edit external ram
                   
                   edit:
05BB: 90 0C 01              mov     dptr, #edits1
05BE: 11 D7                 acall   pcstr
05C0: 71 D7                 acall   r6r7todptr
                   edit1:
05C2: 31 ED                 acall   phex16
05C4: 74 3A                 mov     a, #':'
05C6: 11 C7                 acall   cout_sp
05C8: 74 28                 mov     a, #'('
05CA: 11 A0                 acall   cout
05CC: 71 DC                 acall   dptrtor6r7
05CE: E0                    movx    a, @dptr
05CF: 31 E6                 acall   phex
05D1: 90 0B C3              mov     dptr, #prompt10
05D4: 11 D7                 acall   pcstr
05D6: 11 F8                 acall   ghex
05D8: 20 D5 0E              jb      psw.5, edit2
05DB: 40 0C                 jc      edit2
05DD: 71 D7                 acall   r6r7todptr
05DF: F0                    movx    @dptr, a
05E0: 11 BA                 acall   crlf
05E2: 71 D7                 acall   r6r7todptr
05E4: A3                    inc     dptr
05E5: 71 DC                 acall   dptrtor6r7
05E7: A1 C2                 ajmp    edit1
                   edit2:
05E9: 90 0C 2A              mov     dptr, #edits2
05EC: 01 D7                 ajmp    pcstr
                   
                   ;---------------------------------------------------------;
                   
                   dir:
05EE: 90 0B 9D              mov     dptr, #prompt9
05F1: 11 D7                 acall   pcstr
05F3: 78 15                 mov     r0, #21
                   dir0a:
05F5: 11 A8                 acall   sspace
05F7: D8 FC                 djnz    r0, dir0a
05F9: 90 0B AE              mov     dptr, #prompt9b
05FC: 11 D7                 acall   pcstr
05FE: 75 83 10              mov     dph, #(bmem >> 8)
                   dir1:
0601: 12 09 B0              lcall   find            ; find the next program in 
0604: 40 02                 jc      dir2
                   dir_end:
0606: 01 BA                 ajmp    crlf            ; we're done if no more fou
                   dir2:
0608: 11 CF                 acall   dspace
060A: 75 82 20              mov     dpl, #32        ; print its name
060D: 11 D7                 acall   pcstr
060F: 75 82 20              mov     dpl, #32        ; how long is the name
0612: 51 C6                 acall   lencstr
0614: 74 21                 mov     a, #33
0616: C3                    clr     c
0617: 98                    subb    a, r0
0618: F8                    mov     r0, a
0619: 74 20                 mov     a, #SPACE       ; print the right # of spac
                   dir3:
061B: 11 A0                 acall   cout
061D: D8 FC                 djnz    r0, dir3
061F: 75 82 00              mov     dpl, #0
0622: 31 ED                 acall   phex16          ; print the memory location
0624: 78 06                 mov     r0, #6
0626: 74 20                 mov     a, #SPACE
                   dir4:
0628: 11 A0                 acall   cout
062A: D8 FC                 djnz    r0, dir4
062C: 75 82 04              mov     dpl, #4                 ; now figure out wh
062F: E0                    movx    a, @dptr
0630: AA 83                 mov     r2, dph                 ; save this, we're 
                   dir5:
0632: B4 FE 05              cjne    a, #254, dir5b
0635: 90 0E 19              mov     dptr, #type1    ; it's an external command
0638: 80 18                 sjmp    dir7
                   dir5b:
063A: B4 FD 05              cjne    a, #253, dir5c
                   dir5bb:
063D: 90 0E 32              mov     dptr, #type4    ; it's a startup routine
0640: 80 10                 sjmp    dir7
                   dir5c:
0642: B4 23 05              cjne    a, #35, dir5d
0645: 90 0E 2A              mov     dptr, #type2    ; it's an ordinary program
0648: 80 08                 sjmp    dir7
                   dir5d:
064A: B4 F9 02              cjne    a, #249, dir5e
064D: 80 EE                 sjmp    dir5bb
                   dir5e:
                   dir6:
064F: 90 0E 3F              mov     dptr, #type5    ; who knows what the hell i
                   dir7:
0652: 11 D7                 acall   pcstr           ; print out the type
0654: 8A 83                 mov     dph, r2                 ; go back and find 
0656: 11 BA                 acall   crlf
0658: 74 DF                 mov     a, #(emem >> 8)
065A: B5 83 02              cjne    a, dph, dir8    ; did we just print the las
065D: C1 06                 ajmp    dir_end
                   dir8:
065F: 05 83                 inc     dph
0661: E5 83                 mov     a, dph
0663: B4 E0 9B              cjne    a, #((emem + 1) >> 8) & 0xff, dir1
0666: C1 06                 ajmp    dir_end
                   
                   ; type1=Ext Command
                   ; type4=Startup
                   ; type2=Program
                   ; type5=???
                   
                   ;---------------------------------------------------------;
                   
                   run:
0668: 11 D3                 acall   dcrlf
066A: 7A FF                 mov     r2, #255        ; first print the menu, cou
066C: 90 10 00              mov     dptr, #bmem
066F: 15 83                 dec     dph
                   run2:
0671: 05 83                 inc     dph
0673: E5 83                 mov     a, dph
0675: B4 E0 02              cjne    a, #((emem + 1) >> 8) & 0xff, run2b
0678: 80 21                 sjmp    run3
                   run2b:
067A: 12 09 B0              lcall   find
067D: 50 1C                 jnc     run3            ; have we found 'em all??
067F: 75 82 04              mov     dpl, #4
0682: E0                    movx    a, @dptr
0683: 44 03                 orl     a, #00000011b
0685: F4                    cpl     a
0686: 60 E9                 jz      run2            ; this one doesn't run... f
0688: 11 CF                 acall   dspace
068A: 0A                    inc     r2
068B: 74 41                 mov     a, #pos_A               ; print the key to 
068D: 2A                    add     a, r2
068E: 11 C7                 acall   cout_sp
0690: 11 CB                 acall   dash_sp
0692: 75 82 20              mov     dpl, #32
0695: 11 D7                 acall   pcstr           ; and the command name
0697: 11 BA                 acall   crlf
0699: C1 71                 ajmp    run2            ; and continue doing this
                   run3:
069B: BA FF 05              cjne    r2, #255, run4  ; are there any to run??
069E: 90 0B 22              mov     dptr, #prompt5
06A1: 01 D7                 ajmp    pcstr
                   run4:
06A3: 90 0A F6              mov     dptr, #prompt3  ; ask the big question!
06A6: 11 D7                 acall   pcstr
06A8: 74 41                 mov     a, #pos_A
06AA: 11 A0                 acall   cout
06AC: 11 B1                 acall   dash
06AE: 74 41                 mov     a, #pos_A       ; such user friendliness...
06B0: 2A                    add     a, r2           ; even tell 'em the choices
06B1: 11 A0                 acall   cout
06B3: 90 0B 0E              mov     dptr, #prompt4
06B6: 11 D7                 acall   pcstr
06B8: 11 8E                 acall   cin
06BA: B4 1B 02              cjne    a, #ESC, run4aa         ; they they hit <ES
06BD: 01 BA                 ajmp    crlf
                   run4aa:
06BF: FB                    mov     r3, a
06C0: 74 1F                 mov     a, #31
06C2: C3                    clr     c
06C3: 9A                    subb    a, r2
06C4: EB                    mov     a, r3
06C5: 40 02                 jc      run4a
06C7: 51 BF                 acall   toupper
                   run4a:
06C9: 11 A0                 acall   cout
06CB: FB                    mov     r3, a
06CC: 11 BA                 acall   crlf
                   ; check to see if it's under 32, if so convert to uppercase
06CE: EB                    mov     a, r3
06CF: 24 BF                 add     a, #(256 - pos_A)
06D1: 50 D0                 jnc     run4            ; if they typed less than '
06D3: FB                    mov     r3, a           ; R3 has the number they ty
06D4: EA                    mov     a, r2           ; A=R2 has the maximum numb
06D5: C3                    clr     c
06D6: 9B                    subb    a, r3
06D7: 40 CA                 jc      run4            ; if they typed over the ma
06D9: 0B                    inc     r3
06DA: 90 10 00              mov     dptr, #bmem
06DD: 15 83                 dec     dph
                   run5:
06DF: 05 83                 inc     dph
06E1: E5 83                 mov     a, dph
06E3: B4 E0 02              cjne    a, #((emem + 1) >> 8) & 0xff, run5b
06E6: 80 17                 sjmp    run8
                   run5b:
06E8: 12 09 B0              lcall   find
06EB: 50 12                 jnc     run8            ; Shouldn't ever do this ju
06ED: 75 82 04              mov     dpl, #4
06F0: E0                    movx    a, @dptr
06F1: 44 03                 orl     a, #00000011b
06F3: F4                    cpl     a
06F4: 60 E9                 jz      run5            ; this one doesn't run... f
06F6: DB E7                 djnz    r3, run5        ; count til we find the one
06F8: 11 BA                 acall   crlf
06FA: 75 82 40              mov     dpl, #64
06FD: A1 6B                 ajmp    jump_doit
                   run8:
06FF: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   help:
0700: 90 0D E3              mov     dptr, #help1txt
0703: 11 D7                 acall   pcstr
                            
0705: 7C 3F                 mov     r4, #help_key
0707: 90 0E 48              mov     dptr, #help_cmd
070A: F1 9B                 acall   help2
                            
070C: 7C 4D                 mov     r4, #dir_key
070E: 90 0E 57              mov     dptr, #dir_cmd
0711: F1 9B                 acall   help2
                            
0713: 7C 52                 mov     r4, #run_key
0715: 90 0E 65              mov     dptr, #run_cmd
0718: F1 9B                 acall   help2
                            
071A: 7C 44                 mov     r4, #dnld_key
071C: 90 0E 71              mov     dptr, #dnld_cmd
071F: F1 9B                 acall   help2
                            
0721: 7C 55                 mov     r4, #upld_key
0723: 90 0E 7A              mov     dptr, #upld_cmd
0726: F1 9B                 acall   help2
                            
0728: 7C 4E                 mov     r4, #nloc_key
072A: 90 0E 81              mov     dptr, #nloc_cmd
072D: F1 9B                 acall   help2
                            
072F: 7C 4A                 mov     r4, #jump_key
0731: 90 0E 8E              mov     dptr, #jump_cmd
0734: F1 9B                 acall   help2
                            
0736: 7C 48                 mov     r4, #dump_key
0738: 90 0E A6              mov     dptr, #dump_cmd
073B: F1 9B                 acall   help2
                            
073D: 7C 49                 mov     r4, #intm_key
073F: 90 0E BF              mov     dptr, #intm_cmd
0742: F1 9B                 acall   help2
                            
0744: 7C 45                 mov     r4, #edit_key
0746: 90 0E D8              mov     dptr, #edit_cmd
0749: F1 9B                 acall   help2
                            
074B: 7C 43                 mov     r4, #clrm_key
074D: 90 0E ED              mov     dptr, #clrm_cmd
0750: F1 9B                 acall   help2
                            
0752: 7C 42                 mov     r4, #baud_key
0754: 90 0F 32              mov     dptr, #baud_cmd
0757: F1 9B                 acall   help2
                            
0759: 7C 57                 mov     r4, #crc16_key
075B: 90 0F 03              mov     dptr, #crc16_cmd
075E: F1 9B                 acall   help2
                            
0760: 7C 3C                 mov     r4, #eio77_key
0762: 90 0F 13              mov     dptr, #eio77_cmd
0765: F1 9B                 acall   help2
                            
0767: 7C 3E                 mov     r4, #dio77_key
0769: 90 0F 22              mov     dptr, #dio77_cmd
076C: F1 9B                 acall   help2
                            
076E: 90 0D FC              mov     dptr, #help2txt
0771: 11 D7                 acall   pcstr
0773: 90 10 00              mov     dptr, #bmem
                   help3:
0776: 12 09 B0              lcall   find
0779: 50 1E                 jnc     help4
077B: 75 82 04              mov     dpl, #4
077E: E0                    movx    a, @dptr
077F: B4 FE 10              cjne    a, #254, help3a         ; only FE is an ext
0782: 11 CF                 acall   dspace
0784: 05 82                 inc     dpl
0786: E0                    movx    a, @dptr
0787: 11 C7                 acall   cout_sp
0789: 11 CB                 acall   dash_sp
078B: 75 82 20              mov     dpl, #32
078E: 11 D7                 acall   pcstr
0790: 11 BA                 acall   crlf
                   help3a:
0792: 05 83                 inc     dph
0794: E5 83                 mov     a, dph
0796: B4 E0 DD              cjne    a, #((emem + 1) >> 8) & 0xff, help3
                   help4:
0799: 01 BA                 ajmp    crlf
                   help2:
                   ; print 11 standard lines
079B: 11 CF                 acall   dspace          ; given key in R4 and name 
079D: EC                    mov     a, r4
079E: 11 C7                 acall   cout_sp
07A0: 11 CB                 acall   dash_sp
07A2: 11 D7                 acall   pcstr
07A4: 01 BA                 ajmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   upld:
07A6: 12 08 3F              lcall   get_mem
                   ; assume we've got the beginning address in r3/r2
                   ; and the final address in r5/r4 (r4=lsb)...
                   ; print out what we'll be doing
07A9: 90 0D BF              mov     dptr, #uplds3
07AC: 11 D7                 acall   pcstr
07AE: EB                    mov     a, r3
07AF: 31 E6                 acall   phex
07B1: EA                    mov     a, r2
07B2: 31 E6                 acall   phex
07B4: 90 0D DE              mov      dptr, #uplds4
07B7: 11 D7                 acall   pcstr
07B9: ED                    mov     a, r5
07BA: 31 E6                 acall   phex
07BC: EC                    mov     a, r4
07BD: 31 E6                 acall   phex
07BF: 11 BA                 acall   crlf
                   ; need to adjust end location by 1...
07C1: 8D 83                 mov     dph, r5
07C3: 8C 82                 mov     dpl, r4
07C5: A3                    inc     dptr
07C6: AC 82                 mov     r4, dpl
07C8: AD 83                 mov     r5, dph
07CA: 90 0B 6E              mov     dptr, #prompt7
07CD: 11 D7                 acall   pcstr
07CF: 11 8E                 acall   cin
07D1: B4 1B 03              cjne    a, #ESC, upld2e
07D4: 02 08 76              ljmp    abort_it
                   upld2e:
07D7: 11 D3                 acall   dcrlf
07D9: 8A 82                 mov     dpl, r2
07DB: 8B 83                 mov     dph, r3
                   upld3:
07DD: EC                    mov     a, r4           ; how many more bytes to ou
07DE: C3                    clr     c
07DF: 95 82                 subb    a, dpl
07E1: FA                    mov     r2, a
07E2: ED                    mov     a, r5
07E3: 95 83                 subb    a, dph
07E5: 70 09                 jnz     upld4           ; if >256 left, then do nex
07E7: EA                    mov     a, r2
07E8: 60 3A                 jz      upld7           ; if we're all done
07EA: 54 F0                 anl     a, #11110000b
07EC: 70 02                 jnz     upld4           ; if >= 16 left, then do ne
07EE: 80 02                 sjmp    upld5           ; otherwise just finish it 
                   upld4:
07F0: 7A 10                 mov     r2, #16
                   upld5:
07F2: 74 3A                 mov     a, #':'                 ; begin the line
07F4: 12 00 A0              lcall   cout
07F7: EA                    mov     a, r2
07F8: 12 01 E6              lcall   phex            ; output # of data bytes
07FB: 12 01 ED              lcall   phex16          ; output memory location
07FE: E5 83                 mov     a, dph
0800: 25 82                 add     a, dpl
0802: 2A                    add     a, r2
0803: FB                    mov     r3, a           ; r3 will become checksum
0804: E4                    clr     a
0805: 12 01 E6              lcall   phex            ; output 00 code for data
                   upld6:
0808: E0                    movx    a, @dptr
0809: 12 01 E6              lcall   phex            ; output each byte
080C: 2B                    add     a, r3
080D: FB                    mov     r3, a
080E: A3                    inc     dptr
080F: DA F7                 djnz    r2, upld6       ; do however many bytes we 
0811: EB                    mov     a, r3
0812: F4                    cpl     a
0813: 04                    inc     a
0814: 12 01 E6              lcall   phex            ; and finally the checksum
0817: 12 00 BA              lcall   crlf
081A: 12 00 96              lcall   cinpoll
081D: 40 BE                 jc      upld3
081F: B4 1B BB              cjne    a, #ESC, upld3
0822: 80 52                 sjmp    abort_it
                   upld7:
0824: 74 3A                 mov     a, #':'
0826: 12 00 A0              lcall   cout
0829: E4                    clr     a
082A: 12 01 E6              lcall   phex
082D: 12 01 E6              lcall   phex
0830: 12 01 E6              lcall   phex
0833: 04                    inc     a
0834: 12 01 E6              lcall   phex
0837: 74 FF                 mov     a, #255
0839: 12 01 E6              lcall   phex
                   upld8:
083C: 02 00 D3              ljmp    dcrlf
                   
                   ;---------------------------------------------------------;
                   
                   ; this thing gets the begin and end locations for
                   ; a few commands. If an esc or enter w/ no input,
                   ; it pops it's own return and returns to the menu
                   ; (nasty programming, but we need tight code for 4k rom)
                   
                   get_mem:
083F: 12 00 D3              lcall   dcrlf
0842: 90 0B D1              mov     dptr, #beg_str
0845: 12 00 D7              lcall   pcstr
0848: 12 01 3C              lcall   ghex16
084B: 40 25                 jc      pop_it
084D: 20 D5 22              jb      psw.5, pop_it
0850: C0 83                 push    dph
0852: C0 82                 push    dpl
0854: 12 00 BA              lcall   crlf
0857: 90 0B E2              mov     dptr, #end_str
085A: 12 00 D7              lcall   pcstr
085D: 12 01 3C              lcall   ghex16
0860: AD 83                 mov     r5, dph
0862: AC 82                 mov     r4, dpl
0864: D0 E0                 pop     acc
0866: FA                    mov     r2, a
0867: D0 E0                 pop     acc
0869: FB                    mov     r3, a
086A: 40 06                 jc      pop_it
086C: 20 D5 03              jb      psw.5, pop_it
086F: 02 00 BA              ljmp    crlf
                   pop_it:
0872: D0 E0                 pop     acc
0874: D0 E0                 pop     acc
                   abort_it:
0876: 12 00 BA              lcall   crlf
                   abort2:
0879: 90 0A D2              mov     dptr, #abort
087C: 02 00 D7              ljmp    pcstr
                   
                   ;---------------------------------------------------------;
                   
                   nloc:
087F: 90 0B 5B              mov     dptr, #prompt6
0882: 12 00 D7              lcall   pcstr
0885: 12 01 3C              lcall   ghex16
0888: 40 EF                 jc      abort2
088A: 20 D5 EC              jb      psw.5, abort2
088D: 12 03 DC              lcall   dptrtor6r7
0890: 02 00 D3              ljmp    dcrlf
                   
                   ;---------------------------------------------------------;
                   
                   clrm:
0893: 11 3F                 acall   get_mem
0895: 90 0B F2              mov     dptr, #sure
0898: 12 00 D7              lcall   pcstr
089B: 12 00 8E              lcall   cin
089E: 12 00 A0              lcall   cout
08A1: 12 02 BF              lcall   toupper
08A4: B4 59 CF              cjne    a, #'Y', abort_it
08A7: 12 00 D3              lcall   dcrlf
                   clrm2:
                   ; now we actually do it
08AA: 8B 83                 mov     dph, r3
08AC: 8A 82                 mov     dpl, r2
                   clrm3:
08AE: E4                    clr     a
08AF: F0                    movx    @dptr, a
08B0: ED                    mov     a, r5
08B1: B5 83 05              cjne    a, dph, clrm4
08B4: EC                    mov     a, r4
08B5: B5 82 01              cjne    a, dpl, clrm4
08B8: 22                    ret
                   clrm4:
08B9: A3                    inc     dptr
08BA: 80 F2                 sjmp    clrm3
                   
                   ;---------------------------------------------------------;
                   
                   reset_baud:
08BC: 12 00 D3              lcall   dcrlf
08BF: 90 0F 42              mov     dptr, #baudprompt
08C2: 12 00 D7              lcall   pcstr
08C5: 12 01 3C              lcall   ghex16
08C8: 40 2B                 jc      bailout
08CA: 20 D5 28              jb      psw.5, bailout
08CD: C0 82                 push    dpl
08CF: C0 83                 push    dph
08D1: 12 00 BA              lcall   crlf
08D4: 90 0B F2              mov     dptr, #sure
08D7: 12 00 D7              lcall   pcstr
08DA: 12 00 8E              lcall   cin
08DD: 12 00 A0              lcall   cout
08E0: 12 02 BF              lcall   toupper
08E3: B4 59 0B              cjne    a, #'Y', bailout_pop
08E6: 12 00 D3              lcall   dcrlf
08E9: D0 F0                 pop     b
08EB: D0 E0                 pop     acc
08ED: 12 00 75              lcall   setbaud
08F0: 22                    ret
                   bailout_pop:
08F1: D0 E0                 pop     acc
08F3: D0 E0                 pop     acc
                   bailout:
08F5: 12 00 BA              lcall   crlf
08F8: 90 0A D2              mov     dptr, #abort
08FB: 02 00 D7              ljmp    pcstr
                   
                   ;---------------------------------------------------------;
                   
08FE:              .equ     initial, 0xffff
08FE:              .equ     final, 0x0000
08FE:              .equ     poly, 0x1021
                   
                   calc_crc16:
08FE: 11 3F                 acall   get_mem
0900: 12 00 BA              lcall   crlf
0903: 12 03 D7              lcall   r6r7todptr
0906: C0 82                 push    dpl
0908: C0 83                 push    dph
090A: 8A 82                 mov     dpl, r2
090C: 8B 83                 mov     dph, r3
090E: 7E FF                 mov     r6, #(initial & 0xff)
0910: 7F FF                 mov     r7, #(initial >> 8)
0912: 12 09 40              lcall   init_crc16
0915: 7E 21                 mov     r6, #(poly & 0xff)
0917: 7F 10                 mov     r7, #(poly >> 8)
                   calc_loop:
0919: E0                    movx    a, @dptr
091A: 12 09 54              lcall   update_crc16
091D: ED                    mov     a, r5
091E: B5 83 1C              cjne    a, dph, calc_skip
0921: EC                    mov     a, r4
0922: B5 82 18              cjne    a, dpl, calc_skip
0925: 7E 00                 mov     r6, #(final & 0xff)
0927: 7F 00                 mov     r7, #(final >> 8)
0929: 12 09 49              lcall   finish_crc16
092C: 8A 82                 mov     dpl, r2
092E: 8B 83                 mov     dph, r3
0930: 12 01 ED              lcall   phex16
0933: D0 83                 pop     dph
0935: D0 82                 pop     dpl
0937: 12 03 DC              lcall   dptrtor6r7
093A: 02 00 D3              ljmp    dcrlf
                   calc_skip:
093D: A3                    inc     dptr
093E: 80 D9                 sjmp    calc_loop
                   
                   init_crc16:
0940: C0 E0                 push    acc
0942: EE                    mov     a, r6
0943: FA                    mov     r2, a
0944: EF                    mov     a, r7
0945: FB                    mov     r3, a
0946: D0 E0                 pop     acc
0948: 22                    ret
                   
                   finish_crc16:
0949: C0 E0                 push    acc
094B: EA                    mov     a, r2
094C: 6E                    xrl     a, r6
094D: FA                    mov     r2, a
094E: EB                    mov     a, r3
094F: 6F                    xrl     a, r7
0950: FB                    mov     r3, a
0951: D0 E0                 pop     acc
0953: 22                    ret
                   
                   update_crc16:
0954: C0 F0                 push    b
0956: F5 F0                 mov     b, a
0958: 74 80                 mov     a, #0x80
                   loop:
095A: F8                    mov     r0, a
095B: E5 F0                 mov     a, b
095D: 58                    anl     a, r0
095E: 60 02                 jz      skip0
0960: 74 01                 mov     a, #1
                   skip0:
0962: F9                    mov     r1, a
0963: EB                    mov     a, r3
0964: 23                    rl      a
0965: 54 01                 anl     a, #1
0967: 69                    xrl     a, r1
0968: F9                    mov     r1, a
0969: EA                    mov     a, r2
096A: 2A                    add     a, r2
096B: FA                    mov     r2, a
096C: EB                    mov     a, r3
096D: 33                    rlc     a
096E: FB                    mov     r3, a
096F: E9                    mov     a, r1
0970: 60 06                 jz      skip1
0972: EA                    mov     a, r2
0973: 6E                    xrl     a, r6
0974: FA                    mov     r2, a
0975: EB                    mov     a, r3
0976: 6F                    xrl     a, r7
0977: FB                    mov     r3, a
                   skip1:
0978: E8                    mov     a, r0
0979: C3                    clr     c
097A: 13                    rrc     a
097B: 70 DD                 jnz     loop
097D: D0 F0                 pop     b
097F: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   intm:
0980: 12 00 BA              lcall   crlf
0983: 78 00                 mov     r0, #0
                   intm2:
0985: 12 00 BA              lcall   crlf
0988: E8                    mov     a, r0
0989: 12 01 E6              lcall   phex
098C: 74 3A                 mov     a, #':'
098E: 12 00 A0              lcall   cout
                   intm3:
0991: 12 00 A8              lcall   sspace
0994: E6                    mov     a, @r0
0995: 12 01 E6              lcall   phex
0998: 08                    inc     r0
0999: B8 00 03              cjne    r0, #0, intm4
099C: 02 00 D3              ljmp    dcrlf
                   intm4:
099F: E8                    mov     a, r0
09A0: 54 0F                 anl     a, #00001111b
09A2: 70 ED                 jnz     intm3
09A4: 80 DF                 sjmp    intm2
                   
                   ;---------------------------------------------------------;
                   
                   eio77:
09A6: C2 97                 clr     p1.7
09A8: 02 00 BA              ljmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   dio77:
09AB: D2 97                 setb    p1.7
09AD: 02 00 BA              ljmp    crlf
                   
                   ;---------------------------------------------------------;
                   
                   ; finds the next header in the external memory.
                   ; Input DPTR=point to start search (only MSB used)
                   ; Output DPTR=location of next module
                   ; C=set if a header found, C=clear if no more headers
                   
                   find:
09B0: 75 82 00              mov     dpl, #0
09B3: E0                    movx    a, @dptr
09B4: B4 A5 14              cjne    a, #0xa5, find3
09B7: A3                    inc     dptr
09B8: E0                    movx    a, @dptr
09B9: B4 E5 0F              cjne    a, #0xe5, find3
09BC: A3                    inc     dptr
09BD: E0                    movx    a, @dptr
09BE: B4 E0 0A              cjne    a, #0xe0, find3
09C1: A3                    inc     dptr
09C2: E0                    movx    a, @dptr
09C3: B4 A5 05              cjne    a, #0xa5, find3
09C6: 75 82 00              mov     dpl, #0                 ; found one here!
09C9: D3                    setb    c
09CA: 22                    ret
                   find3:
09CB: 74 DF                 mov     a, #(emem >> 8)
09CD: B5 83 02              cjne    a, dph, find4   ; did we just check the end
09D0: C3                    clr     c
09D1: 22                    ret
                   find4:
09D2: 05 83                 inc     dph             ; keep on searching
09D4: 80 DA                 sjmp    find
                   
                   ;---------------------------------------------------------;
                   
                   stcode:
09D6: 90 10 00              mov     dptr, #bmem      ; search for startup routi
                   stcode2:
09D9: 12 09 B0              lcall   find
09DC: 50 23                 jnc     stcode5
09DE: 75 82 04              mov     dpl, #4
09E1: E0                    movx    a, @dptr
09E2: B5 F0 15              cjne    a, b, stcode4   ; only startup code if matc
09E5: C0 F0                 push    b
09E7: C0 83                 push    dph
09E9: 74 F6                 mov     a, #(stcode3 & 0xff)
09EB: C0 E0                 push    acc
09ED: 74 09                 mov     a, #(stcode3 >> 8)
09EF: C0 E0                 push    acc
09F1: 75 82 40              mov     dpl, #64
09F4: E4                    clr     a
09F5: 73                    jmp     @a+dptr                 ; jump to the start
                   stcode3:
09F6: D0 83                 pop     dph             ; hopefully it'll return to
09F8: D0 F0                 pop     b
                   stcode4:
09FA: 05 83                 inc     dph
09FC: E5 83                 mov     a, dph
09FE: B4 E0 D8              cjne    a, #((emem + 1) >> 8) & 0xff, stcode2
                   stcode5:
0A01: 22                    ret                     ; now we've executed all of
                   
                   ;---------------------------------------------------------;
                   
                   ; copy from c [lssrc:hssrc, lesrc:hesrc) to x [ldst:hdst, ..
                   ; r2:r3 lssrc:hssrc
                   ; r4:r5 lesrc:hesrc
                   ; r6:r7 ldst:hdst
                   
                   cpycx:
0A02: 8A 82                 mov     dpl, r2
0A04: 8B 83                 mov     dph, r3
0A06: E4                    clr     a
0A07: 93                    movc    a, @a+dptr
0A08: A3                    inc     dptr
0A09: AA 82                 mov     r2, dpl
0A0B: AB 83                 mov     r3, dph
0A0D: 8E 82                 mov     dpl, r6
0A0F: 8F 83                 mov     dph, r7
0A11: F0                    movx    @dptr, a
0A12: A3                    inc     dptr
0A13: AE 82                 mov     r6, dpl
0A15: AF 83                 mov     r7, dph
0A17: EA                    mov     a, r2
0A18: 8C F0                 mov     b, r4
0A1A: B5 F0 E5              cjne    a, b, cpycx
0A1D: EB                    mov     a, r3
0A1E: 8D F0                 mov     b, r5
0A20: B5 F0 DF              cjne    a, b, cpycx
0A23: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   ; copy from x [lssrc:hssrc, lesrc:hesrc) to x [ldst:hdst, ..
                   ; r2:r3 lssrc:hssrc
                   ; r4:r5 lesrc:hesrc
                   ; r6:r7 ldst:hdst
                   
                   cpyxx:
0A24: 8A 82                 mov     dpl, r2
0A26: 8B 83                 mov     dph, r3
0A28: E0                    movx    a, @dptr
0A29: A3                    inc     dptr
0A2A: AA 82                 mov     r2, dpl
0A2C: AB 83                 mov     r3, dph
0A2E: 8E 82                 mov     dpl, r6
0A30: 8F 83                 mov     dph, r7
0A32: F0                    movx    @dptr, a
0A33: A3                    inc     dptr
0A34: AE 82                 mov     r6, dpl
0A36: AF 83                 mov     r7, dph
0A38: EA                    mov     a, r2
0A39: 8C F0                 mov     b, r4
0A3B: B5 F0 E6              cjne    a, b, cpyxx
0A3E: EB                    mov     a, r3
0A3F: 8D F0                 mov     b, r5
0A41: B5 F0 E0              cjne    a, b, cpyxx
0A44: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                            ;-------- switch_shadow helper subroutine --------
                            switch_shadow:
0A45: 75 90 FE                      mov     p1, #mctrl_shadow
0A48: FF                            mov     r7, a
0A49: FF                            mov     r7, a
0A4A: FF                            mov     r7, a
0A4B: FF                            mov     r7, a
0A4C: 22                            ret
                            switch_shadow_end:
                            ;-------- switch_shadow helper subroutine --------
                   
                   ; initialize the hardware on reset
                   ; copy flash to memory
                   
                   reset:
0A4D: E4                    clr     a
0A4E: F5 A8                 mov     ie, a
0A50: F5 B8                 mov     ip, a
0A52: 75 90 FF              mov     p1, #mctrl_reset
0A55: FF                    mov     r7, a
0A56: FF                    mov     r7, a
0A57: FF                    mov     r7, a
0A58: FF                    mov     r7, a
0A59: 75 A0 FF              mov     p2, #p2_init
0A5C: 75 D0 00              mov     psw, #psw_init
0A5F: 75 81 17              mov     sp, #sp_init
0A62: 7A 00                 mov     r2, #0x00       ; lssrc
0A64: 7B 00                 mov     r3, #0x00       ; hssrc
0A66: 7C 00                 mov     r4, #0x00       ; lesrc
0A68: 7D 20                 mov     r5, #0x20       ; hesrc
0A6A: 7E 00                 mov     r6, #0x00       ; ldst
0A6C: 7F 00                 mov     r7, #0x00       ; hdst
0A6E: 12 0A 02              lcall   cpycx
0A71: 7A 45                 mov     r2, #(switch_shadow & 0xff)     ; lssrc
0A73: 7B 0A                 mov     r3, #(switch_shadow >> 8)       ; hssrc
0A75: 7C 4D                 mov     r4, #(switch_shadow_end & 0xff)         ; l
0A77: 7D 0A                 mov     r5, #(switch_shadow_end >> 8)   ; hesrc
0A79: 7E 00                 mov     r6, #(pgm & 0xff)       ; ldst
0A7B: 7F 20                 mov     r7, #(pgm >> 8)                 ; hdst
0A7D: 12 0A 02              lcall   cpycx
0A80: 12 20 00              lcall   pgm             ; switch_shadow
                   ; initialize the serial port
0A83: 74 F7                 mov     a, #(bc & 0xff)         ; lsb
0A85: 75 F0 FF              mov     b, #(bc >> 8)   ; msb
0A88: 12 00 75              lcall   setbaud
                   ; run any user initialization programs in external memory
0A8B: 75 F0 F9              mov     b, #249
0A8E: 12 09 D6              lcall   stcode
                   ; run the start-up programs in external memory
0A91: 75 F0 FD              mov     b, #253
0A94: 12 09 D6              lcall   stcode
0A97: 12 00 BA              lcall   crlf
0A9A: 12 00 BA              lcall   crlf
0A9D: 12 00 BA              lcall   crlf
0AA0: 12 00 BA              lcall   crlf
0AA3: 90 0A B3              mov     dptr, #logon
0AA6: 12 00 D7              lcall   pcstr
0AA9: 12 05 EE              lcall   dir
0AAC: 7E 00                 mov     r6, #(pgm & 0xff)
0AAE: 7F 20                 mov     r7, #(pgm >> 8)
0AB0: 02 02 E5              ljmp    menu
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;         Strings                                          ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   logon:
0AB3: 50 41 55 4C 
      4D 4F 4E 32 
      20 76 32 2E 
      31 61 62 20 
      32 30 32 34 
      31 30 32 38 
      30 30 0D 0A 
      0D 0A 00              .db     "PAULMON2 v2.1ab 2024102800\r\n\r\n", 0
                   abort:
0AD2: 20 20 43 6F 
      6D 6D 61 6E 
      64 20 61 62 
      6F 72 74 65 
      64 0D 0A 0D 
      0A 00                 .db     "  Command aborted\r\n\r\n", 0
                   prompt1:
0AE8: 4C 6F 63 61 
      74 69 6F 6E 
      3A 00                 .db     "Location:", 0
                   prompt2:
0AF2: 20 3E 20 00 
                            .db     " > ", 0
                   prompt3:
0AF6: 53 65 6C 65 
      63 74 20 70 
      72 6F 67 72 
      61 6D 20 74 
      6F 20 72 75 
      6E 20 28 00 
                            .db     "Select program to run (", 0
                   prompt4:
0B0E: 29 20 6F 72 
      20 45 53 43 
      20 74 6F 20 
      61 62 6F 72 
      74 3A 20 00 
                            .db     ") or ESC to abort: ", 0
                   prompt5:
0B22: 4E 6F 20 70 
      72 6F 67 72 
      61 6D 20 68 
      65 61 64 65 
      72 73 20 66 
      6F 75 6E 64 
      20 69 6E 20 
      6D 65 6D 6F 
      72 79 2C 20 
      75 73 65 20 
      4A 55 4D 50 
      20 69 6E 73 
      74 65 61 64 
      0D 0A 0D 0A 
      00                    .db     "No program headers found in memory, use JU
                   prompt6:
0B5B: 0D 0A 0D 0A 
      4E 65 77 20 
      6C 6F 63 61 
      74 69 6F 6E 
      3A 20 00              .db     "\r\n\r\nNew location: ", 0
                   prompt7:
0B6E: 50 72 65 73 
      73 20 61 6E 
      79 20 6B 65 
      79 2E 2E 2E 
      00                    .db     "Press any key...", 0
                   prompt8:
0B7F: 0D 0A 0D 0A 
      4A 75 6D 70 
      20 74 6F 20 
      6D 65 6D 6F 
      72 79 20 6C 
      6F 63 61 74 
      69 6F 6E 20 
      28 00                 .db     "\r\n\r\nJump to memory location (", 0
                   prompt9:
0B9D: 0D 0A 0D 0A 
      50 72 6F 67 
      72 61 6D 20 
      4E 61 6D 65 
      00                    .db     "\r\n\r\nProgram Name", 0
                   prompt9b:
0BAE: 4C 6F 63 61 
      74 69 6F 6E 
      20 20 20 20 
      20 20 54 79 
      70 65 0D 0A 
      00                    .db     "Location      Type\r\n", 0
                   prompt10:
0BC3: 29 20 4E 65 
      77 20 76 61 
      6C 75 65 3A 
      20 00                 .db     ") New value: ", 0
                   beg_str:
0BD1: 46 69 72 73 
      74 20 6C 6F 
      63 61 74 69 
      6F 6E 3A 20 
      00                    .db     "First location: ", 0
                   end_str:
0BE2: 4C 61 73 74 
      20 6C 6F 63 
      61 74 69 6F 
      6E 3A 20 00 
                            .db     "Last location: ", 0
                   sure:
0BF2: 41 72 65 20 
      79 6F 75 20 
      73 75 72 65 
      3F 20 00              .db     "Are you sure? ", 0
                   edits1:
0C01: 0D 0A 0D 0A 
      45 64 69 74 
      69 6E 67 20 
      65 78 74 65 
      72 6E 61 6C 
      20 52 41 4D 
      2C 20 45 53 
      43 20 74 6F 
      20 61 62 6F 
      72 74 0D 0A 
      00                    .db     "\r\n\r\nEditing external RAM, ESC to abort
                   edits2:
0C2A: 20 20 45 64 
      69 74 69 6E 
      67 20 63 6F 
      6D 70 6C 65 
      74 65 2C 20 
      74 68 69 73 
      20 6C 6F 63 
      61 74 69 6F 
      6E 20 75 6E 
      63 68 61 6E 
      67 65 64 0D 
      0A 0D 0A 00 
                            .db     "  Editing complete, this location unchange
                   dnlds1:
0C5A: 0D 0A 0D 0A 
      42 65 67 69 
      6E 20 74 72 
      61 6E 73 66 
      65 72 20 6F 
      66 20 49 6E 
      74 65 6C 20 
      68 65 78 20 
      66 69 6C 65 
      2C 20 45 53 
      43 20 74 6F 
      20 61 62 6F 
      72 74 0D 0A 
      0D 0A 00              .db     "\r\n\r\nBegin transfer of Intel hex file, 
                   dnlds2:
0C91: 0D 0A 44 6F 
      77 6E 6C 6F 
      61 64 20 61 
      62 6F 72 74 
      65 64 0D 0A 
      0D 0A 00              .db     "\r\nDownload aborted\r\n\r\n", 0
                   dnlds3:
0CA8: 0D 0A 44 6F 
      77 6E 6C 6F 
      61 64 20 63 
      6F 6D 70 6C 
      65 74 65 64 
      0D 0A 0D 0A 
      00                    .db     "\r\nDownload completed\r\n\r\n", 0
                   dnlds4:
0CC1: 53 75 6D 6D 
      61 72 79 3A 
      0D 0A 00              .db     "Summary:\r\n", 0
                   dnlds5:
0CCC: 20 20 6C 69 
      6E 65 73 20 
      72 65 63 65 
      69 76 65 64 
      0D 0A 00              .db     "  lines received\r\n", 0
                   dnlds6a:
0CDF: 20 20 62 79 
      74 65 73 20 
      72 65 63 65 
      69 76 65 64 
      0D 0A 00              .db     "  bytes received\r\n", 0
                   dnlds6b:
0CF2: 20 20 62 79 
      74 65 73 20 
      77 72 69 74 
      74 65 6E 0D 
      0A 00                 .db     "  bytes written\r\n", 0
                   dnlds7:
0D04: 45 72 72 6F 
      72 73 3A 0D 
      0A 00                 .db     "Errors:\r\n", 0
                   dnlds8:
0D0E: 20 20 62 79 
      74 65 73 20 
      75 6E 61 62 
      6C 65 20 74 
      6F 20 77 72 
      69 74 65 0D 
      0A 00                 .db     "  bytes unable to write\r\n", 0
                   dnlds9:
0D28: 20 20 62 61 
      64 20 63 68 
      65 63 6B 73 
      75 6D 73 0D 
      0A 00                 .db     "  bad checksums\r\n", 0
                   dnlds10:
0D3A: 20 20 75 6E 
      65 78 70 65 
      63 74 65 64 
      20 62 65 67 
      69 6E 20 6F 
      66 20 6C 69 
      6E 65 0D 0A 
      00                    .db     "  unexpected begin of line\r\n", 0
                   dnlds11:
0D57: 20 20 75 6E 
      65 78 70 65 
      63 74 65 64 
      20 68 65 78 
      20 64 69 67 
      69 74 73 0D 
      0A 00                 .db     "  unexpected hex digits\r\n", 0
                   dnlds12:
0D71: 20 20 75 6E 
      65 78 70 65 
      63 74 65 64 
      20 6E 6F 6E 
      20 68 65 78 
      20 64 69 67 
      69 74 73 0D 
      0A 00                 .db     "  unexpected non hex digits\r\n", 0
                   dnlds13:
0D8F: 4E 6F 20 65 
      72 72 6F 72 
      73 20 64 65 
      74 65 63 74 
      65 64 0D 0A 
      0D 0A 00              .db     "No errors detected\r\n\r\n", 0
                   runs1:
0DA6: 0D 0A 52 75 
      6E 6E 69 6E 
      67 20 70 72 
      6F 67 72 61 
      6D 2E 2E 2E 
      0D 0A 0D 0A 
      00                    .db     "\r\nRunning program...\r\n\r\n", 0
                   uplds3:
0DBF: 0D 0A 53 65 
      6E 64 69 6E 
      67 20 49 6E 
      74 65 6C 20 
      68 65 78 20 
      66 69 6C 65 
      20 66 72 6F 
      6D 20 00              .db     "\r\nSending Intel hex file from ", 0
                   uplds4:
0DDE: 20 74 6F 20 
      00                    .db     " to ", 0
                   help1txt:
0DE3: 0D 0A 0D 0A 
      53 74 61 6E 
      64 61 72 64 
      20 63 6F 6D 
      6D 61 6E 64 
      73 3A 0D 0A 
      00                    .db     "\r\n\r\nStandard commands:\r\n", 0
                   help2txt:
0DFC: 0D 0A 55 73 
      65 72 20 69 
      6E 73 74 61 
      6C 6C 65 64 
      20 63 6F 6D 
      6D 61 6E 64 
      73 3A 0D 0A 
      00                    .db     "\r\nUser installed commands:\r\n", 0
                   type1:
0E19: 45 78 74 65 
      72 6E 61 6C 
      20 63 6F 6D 
      6D 61 6E 64 
      00                    .db     "External command", 0
                   type2:
0E2A: 50 72 6F 67 
      72 61 6D 00 
                            .db     "Program", 0
                   type4:
0E32: 53 74 61 72 
      74 75 70 20 
      63 6F 64 65 
      00                    .db     "Startup code", 0
                   type5:
0E3F: 3F 3F 3F 00 
                            .db     "???", 0
                   help_cmd2:
0E43: 48 65 6C 70 
      00                    .db     "Help", 0
                   help_cmd:
0E48: 54 68 69 73 
      20 68 65 6C 
      70 20 6C 69 
      73 74 00              .db     "This help list", 0
                   dir_cmd:
0E57: 4C 69 73 74 
      20 70 72 6F 
      67 72 61 6D 
      73 00                 .db     "List programs", 0
                   run_cmd:
0E65: 52 75 6E 20 
      70 72 6F 67 
      72 61 6D 00 
                            .db     "Run program", 0
                   dnld_cmd:
0E71: 44 6F 77 6E 
      6C 6F 61 64 
      00                    .db     "Download", 0
                   upld_cmd:
0E7A: 55 70 6C 6F 
      61 64 00              .db     "Upload", 0
                   nloc_cmd:
0E81: 4E 65 77 20 
      6C 6F 63 61 
      74 69 6F 6E 
      00                    .db     "New location", 0
                   jump_cmd:
0E8E: 4A 75 6D 70 
      20 74 6F 20 
      6D 65 6D 6F 
      72 79 20 6C 
      6F 63 61 74 
      69 6F 6E 00 
                            .db     "Jump to memory location", 0
                   dump_cmd:
0EA6: 48 65 78 20 
      64 75 6D 70 
      20 65 78 74 
      65 72 6E 61 
      6C 20 6D 65 
      6D 6F 72 79 
      00                    .db     "Hex dump external memory", 0
                   intm_cmd:
0EBF: 48 65 78 20 
      64 75 6D 70 
      20 69 6E 74 
      65 72 6E 61 
      6C 20 6D 65 
      6D 6F 72 79 
      00                    .db     "Hex dump internal memory", 0
                   edit_cmd:
0ED8: 45 64 69 74 
      20 65 78 74 
      65 72 6E 61 
      6C 20 6D 65 
      6D 6F 72 79 
      00                    .db     "Edit external memory", 0
                   clrm_cmd:
0EED: 43 6C 65 61 
      72 20 65 78 
      74 65 72 6E 
      61 6C 20 6D 
      65 6D 6F 72 
      79 00                 .db     "Clear external memory", 0
                   crc16_cmd:
0F03: 43 61 6C 63 
      75 6C 61 74 
      65 20 43 52 
      43 31 36 00 
                            .db     "Calculate CRC16", 0
                   eio77_cmd:
0F13: 45 6E 61 62 
      6C 65 20 6E 
      43 53 49 4F 
      37 37 00              .db     "Enable nCSIO77", 0
                   dio77_cmd:
0F22: 44 69 73 61 
      62 6C 65 20 
      6E 43 53 49 
      4F 37 37 00 
                            .db     "Disable nCSIO77", 0
                   baud_cmd:
0F32: 52 65 73 65 
      74 20 62 61 
      75 64 20 72 
      61 74 65 00 
                            .db     "Reset baud rate", 0
                   baudprompt:
0F42: 45 6E 74 65 
      72 20 6E 65 
      77 20 62 61 
      75 64 20 63 
      6F 6E 73 74 
      3A 20 00              .db     "Enter new baud const: ", 0
0F59: 45 6E 74 65 
      72 20 6E 65 
      77 20 62 61 
      75 64 20 63 
      6F 6E 73 74 
      3A 20 00              .db     "Enter new baud const: ", 0
